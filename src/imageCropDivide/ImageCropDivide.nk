Group {
 name imageCropDivide
 tile_color 0x5c3d84ff
 addUserKnob {20 User}
 addUserKnob {3 width_max}
 width_max 1920
 addUserKnob {3 height_max -STARTLINE}
 height_max 1080
 addUserKnob {3 width_source}
 width_source {{width}}
 addUserKnob {3 height_source -STARTLINE}
 height_source {{height}}
 addUserKnob {26 "" +STARTLINE}
 addUserKnob {22 icd_script l "Copy Setup to ClipBoard" T "\"\"\"\nversion=4\nauthor=Liam Collod\nlast_modified=24/04/2022\npython>2.7\ndependencies=\{\n    nuke=*\n\}\n\n[What]\n\nFrom given maximum dimensions, divide an input image into multiples crops.\nThis a combined script of <cropAndWrite> and <imageCropDivide>.\nMust be executed from a python button knob.\n\n[Use]\n\nMust be executed from a python button knob.\n\n[License]\n\nCopyright 2022 Liam Collod\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n\"\"\"\n\nimport logging\nimport math\nimport platform\nimport subprocess\nimport sys\n\ntry:\n    from typing import Tuple, List\nexcept ImportError:\n    pass\n\nimport nuke\n\n\nLOGGER = logging.getLogger(\"\{\}.\{\}\".format(nuke.thisNode(), nuke.thisKnob()))\n\n# dynamically replaced on build\nPASS_NUKE_TEMPLATE = 'Dot \{\\n name Dot_%PASS_ID%_1\\n xpos %PASS_XPOS%\\n ypos 0\\n\}\\nCrop \{\\n name Crop_%PASS_ID%_1\\n xpos %PASS_XPOS%\\n ypos 50\\n box \{%BOX_X% %BOX_Y% %BOX_R% %BOX_T%\}\\n reformat true\\n\}\\nModifyMetadata \{\\n name ModifyMetadata_%PASS_ID%_1\\n xpos %PASS_XPOS%\\n ypos 100\\n metadata \{\{set %METADATA_KEY% %PASS_ID%\}\}\\n\}\\nclone $%WRITE_CLONE_ID% \{\\n xpos %PASS_XPOS%\\n ypos 150\\n\}\\n'\nWRITE_MASTER_NUKE_TEMPLATE = 'Write \{\\n xpos 0\\n ypos -100\\n file \"[metadata %METADATA_KEY%].jpg\"\\n file_type jpeg\\n _jpeg_quality 1\\n _jpeg_sub_sampling 4:4:4\\n\}'\n\n\nclass CropCoordinate:\n    \"\"\"\n    Dataclass or \"struct\" that just hold multipel attribute represent a crop coordinates.\n    \"\"\"\n\n    def __init__(self, x_start, y_start, x_end, y_end, width_index, height_index):\n        self.x_start = x_start\n        self.y_start = y_start\n        self.x_end = x_end\n        self.y_end = y_end\n        self.width_index = width_index\n        self.height_index = height_index\n\n\ndef generate_crop_coordinates(width_max, height_max, width_source, height_source):\n    \"\"\"\n    Args:\n        width_max (int): maximum allowed width for each crop\n        height_max (int): maximum allowed height for each crop\n        width_source (int): width of the source to crop\n        height_source (int): height of the source to crop\n\n    Returns:\n        list[CropCoordinate]: list of crops to perform to match the given parameters requested\n    \"\"\"\n    width_crops_n = math.ceil(width_source / width_max)\n    height_crops_n = math.ceil(height_source / height_max)\n\n    if not width_crops_n or not height_crops_n:\n        raise RuntimeError(\n            \"[generate_crop_coordinates] Can't find a number of crop to perform on r(\{\})\"\n            \" or t(\{\}) for the following setup :\\n\"\n            \"max=\{\}x\{\} ; source=\{\}x\{\}\".format(\n                width_crops_n,\n                height_crops_n,\n                width_max,\n                height_max,\n                width_source,\n                height_source,\n            )\n        )\n\n    width_crops = []\n\n    for i in range(width_crops_n):\n        start = width_source / width_crops_n * i\n        end = width_source / width_crops_n * i + (width_source / width_crops_n)\n        width_crops.append((start, end))\n\n    height_crops = []\n\n    for i in range(height_crops_n):\n        start = height_source / height_crops_n * i\n        end = height_source / height_crops_n * i + (height_source / height_crops_n)\n        height_crops.append((start, end))\n\n    crops = []\n\n    # ORDER matter we are trying to get :\n    # [0] > [1] >\n    # [2] > [3] > ...\n    # that is expected by oiiotool\n    # https://openimageio.readthedocs.io/en/latest/oiiotool.html#cmdoption-mosaic\n    for height_i in range(len(height_crops)):\n        for width_i in range(len(width_crops)):\n            crop = CropCoordinate(\n                x_start=width_crops[width_i][0],\n                y_start=height_crops[height_i][0],\n                x_end=width_crops[width_i][1],\n                y_end=height_crops[height_i][1],\n                width_index=width_i,\n                height_index=height_i,\n            )\n            crops.append(crop)\n\n    return crops\n\n\ndef register_in_clipboard(data):\n    \"\"\"\n    Args:\n        data(str):\n    \"\"\"\n\n    # Check which operating system is running to get the correct copying keyword.\n    if platform.system() == \"Darwin\":\n        copy_keyword = \"pbcopy\"\n    elif platform.system() == \"Windows\":\n        copy_keyword = \"clip\"\n    else:\n        raise OSError(\"Current os not supported. Only [Darwin, Windows]\")\n\n    subprocess.run(copy_keyword, universal_newlines=True, input=data)\n    return\n\n\ndef generate_nk(\n    width_max,\n    height_max,\n    width_source,\n    height_source,\n):\n    \"\"\"\n\n    Args:\n        width_max(int):\n        height_max(int):\n        width_source(int):\n        height_source(int):\n\n    Returns:\n        str: .nk formatted string representing the nodegraph\n    \"\"\"\n\n    crop_coordinates = generate_crop_coordinates(\n        width_max,\n        height_max,\n        width_source,\n        height_source,\n    )\n\n    out = \"\"\n\n    master_write_id = \"C171d00\"\n    pass_metadata_key = \"__crop/pass_id\"\n\n    master_write = WRITE_MASTER_NUKE_TEMPLATE.replace(\n        \"%METADATA_KEY%\", pass_metadata_key\n    )\n    out += \"clone node7f6100171d00|Write|21972 \{\}\\n\".format(master_write)\n    out += \"set \{\} [stack 0]\\n\".format(master_write_id)\n\n    for index, crop_coordinate in enumerate(\n        crop_coordinates\n    ):  # type: int, CropCoordinate\n        pass_nk = PASS_NUKE_TEMPLATE\n        pass_id = \"\{\}x\{\}\".format(\n            crop_coordinate.width_index, crop_coordinate.height_index\n        )\n        pos_x = 125 * index\n\n        pass_nk = pass_nk.replace(\"%PASS_ID%\", str(pass_id))\n        pass_nk = pass_nk.replace(\"%PASS_XPOS%\", str(pos_x))\n        pass_nk = pass_nk.replace(\"%WRITE_CLONE_ID%\", str(master_write_id))\n        pass_nk = pass_nk.replace(\"%METADATA_KEY%\", str(pass_metadata_key))\n        pass_nk = pass_nk.replace(\"%BOX_X%\", str(crop_coordinate.x_end))\n        pass_nk = pass_nk.replace(\"%BOX_Y%\", str(crop_coordinate.y_end))\n        pass_nk = pass_nk.replace(\"%BOX_R%\", str(crop_coordinate.x_start))\n        pass_nk = pass_nk.replace(\"%BOX_T%\", str(crop_coordinate.y_start))\n\n        out += \"\{\}push $\{\}\\n\".format(pass_nk, master_write_id)\n        continue\n\n    LOGGER.info(\"[generate_nk] Finished.\")\n    return out\n\n\ndef run():\n    def _check(variable, name):\n        if not variable:\n            raise ValueError(\"\{\} can't be False/None/0\".format(name))\n\n    LOGGER.info(\"[run] Started.\")\n\n    width_max = nuke.thisNode()[\"width_max\"].getValue()\n    height_max = nuke.thisNode()[\"height_max\"].getValue()\n    width_source = nuke.thisNode()[\"width_source\"].getValue()\n    height_source = nuke.thisNode()[\"height_source\"].getValue()\n\n    _check(width_max, \"width_max\")\n    _check(height_max, \"height_max\")\n    _check(width_source, \"width_source\")\n    _check(height_source, \"height_source\")\n\n    nk_str = generate_nk(\n        width_max=width_max,\n        height_max=height_max,\n        width_source=width_source,\n        height_source=height_source,\n    )\n    register_in_clipboard(nk_str)\n\n    LOGGER.info(\"[run] Finished. Nodegraph copied to clipboard.\")\n    return\n\n\n# remember: this modifies the root LOGGER only if it never has been before\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(levelname)-7s | %(asctime)s [%(name)s] %(message)s\",\n)\nrun()\n" +STARTLINE}
 addUserKnob {26 info l " " T "press ctrl+v in the nodegraph after clicking the above button"}
 addUserKnob {20 About}
 addUserKnob {26 toolName l name T ImageCropDivide}
 addUserKnob {26 toolVersion l version T 0.8.0}
 addUserKnob {26 toolAuthor l author T "<a style=\"color: rgb(200,200,200);\" href=\"https://mrlixm.github.io/\">Liam Collod</a>"}
 addUserKnob {26 toolDescription l description T "Reshape a colorspace gamut and plot it on the CIE xy space."}
 addUserKnob {26 toolUrl l url T "<a style=\"color: rgb(200,200,200);\" href=\"https://github.com/MrLixm/Foundry_Nuke\">https://github.com/MrLixm/Foundry_Nuke</a>"}
}
 Input {
  inputs 0
  name Input1
  xpos 0
 }
 Output {
  name Output1
  xpos 0
  ypos 300
 }
end_group
