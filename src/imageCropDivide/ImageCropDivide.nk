Group {
 name imageCropDivide
 tile_color 0x5c3d84ff
 addUserKnob {20 User}
 addUserKnob {26 header_step1 l " " T "<h2>Step1</h2>"}
 addUserKnob {3 width_max l "Width Max"}
 width_max 1920
 addUserKnob {3 height_max l "Height Max" -STARTLINE}
 height_max 1080
 addUserKnob {3 width_source l "Width Source"}
 width_source {{width}}
 addUserKnob {3 height_source l "Height Source" -STARTLINE}
 height_source {{height}}
 addUserKnob {2 export_directory l "Export Directory" +STARTLINE}
 addUserKnob {1 combined_filename l "Combined File Name" t "without file extension" +STARTLINE}
 addUserKnob {26 "" +STARTLINE}
 addUserKnob {26 header_step2 l " " T "<h2>Step2</h2>"}
 addUserKnob {22 icd_script l "Copy Setup to ClipBoard" T "\"\"\"\nversion=4\nauthor=Liam Collod\nlast_modified=24/04/2022\npython>2.7\ndependencies=\{\n    nuke=*\n\}\n\n[What]\n\nFrom given maximum dimensions, divide an input image into multiples crops.\nThis a combined script of <cropAndWrite> and <imageCropDivide>.\nMust be executed from a python button knob.\n\n[Use]\n\nMust be executed from a python button knob.\n\n[License]\n\nCopyright 2022 Liam Collod\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n\"\"\"\n\nimport logging\nimport math\nimport platform\nimport subprocess\nimport sys\n\ntry:\n    from typing import Tuple, List\nexcept ImportError:\n    pass\n\nimport nuke\n\n\nLOGGER = logging.getLogger(\"\{\}.\{\}\".format(nuke.thisNode(), nuke.thisKnob()))\n\n# dynamically replaced on build\nPASS_NUKE_TEMPLATE = 'Dot \{\\n name Dot_%PASS_ID%_1\\n xpos %PASS_XPOS%\\n ypos 0\\n\}\\nCrop \{\\n name Crop_%PASS_ID%_1\\n xpos %PASS_XPOS%\\n ypos 50\\n box \{%BOX_X% %BOX_Y% %BOX_R% %BOX_T%\}\\n reformat true\\n\}\\nModifyMetaData \{\\n name ModifyMetaData_%PASS_ID%_1\\n xpos %PASS_XPOS%\\n ypos 100\\n metadata \{\{set %METADATA_KEY% %PASS_ID%\}\}\\n\}\\nclone $%WRITE_CLONE_ID% \{\\n xpos %PASS_XPOS%\\n ypos 150\\n\}\\n'\nWRITE_MASTER_NUKE_TEMPLATE = 'Write \{\\n xpos 0\\n ypos -100\\n file \"[value %ICD_NODE%.export_directory]/[metadata %METADATA_KEY%].jpg\"\\n file_type jpeg\\n _jpeg_quality 1\\n _jpeg_sub_sampling 4:4:4\\n\}'\n\n\nclass CropCoordinate:\n    \"\"\"\n    Dataclass or \"struct\" that just hold multipel attribute represent a crop coordinates.\n    \"\"\"\n\n    def __init__(self, x_start, y_start, x_end, y_end, width_index, height_index):\n        self.x_start = x_start\n        self.y_start = y_start\n        self.x_end = x_end\n        self.y_end = y_end\n        self.width_index = width_index\n        self.height_index = height_index\n\n\ndef generate_crop_coordinates(width_max, height_max, width_source, height_source):\n    \"\"\"\n    Args:\n        width_max (int): maximum allowed width for each crop\n        height_max (int): maximum allowed height for each crop\n        width_source (int): width of the source to crop\n        height_source (int): height of the source to crop\n\n    Returns:\n        list[CropCoordinate]: list of crops to perform to match the given parameters requested\n    \"\"\"\n    width_crops_n = math.ceil(width_source / width_max)\n    height_crops_n = math.ceil(height_source / height_max)\n\n    if not width_crops_n or not height_crops_n:\n        raise RuntimeError(\n            \"[generate_crop_coordinates] Can't find a number of crop to perform on r(\{\})\"\n            \" or t(\{\}) for the following setup :\\n\"\n            \"max=\{\}x\{\} ; source=\{\}x\{\}\".format(\n                width_crops_n,\n                height_crops_n,\n                width_max,\n                height_max,\n                width_source,\n                height_source,\n            )\n        )\n\n    width_crops = []\n\n    for i in range(width_crops_n):\n        start = width_source / width_crops_n * i\n        end = width_source / width_crops_n * i + (width_source / width_crops_n)\n        width_crops.append((start, end))\n\n    height_crops = []\n\n    for i in range(height_crops_n):\n        start = height_source / height_crops_n * i\n        end = height_source / height_crops_n * i + (height_source / height_crops_n)\n        height_crops.append((start, end))\n\n    # nuke assume 0,0 is bottom left but we want 0,0 to be top-left\n    height_crops.reverse()\n\n    # XXX: we round all decimals to the above integer to avoid \"black stripe\" when\n    #   combining the image because there is some missing pixels\n\n    crops = []\n\n    for width_i, width in enumerate(width_crops):\n        for height_i, height in enumerate(height_crops):\n            crop = CropCoordinate(\n                x_start=math.ceil(width[0]),\n                y_start=math.ceil(height[0]),\n                x_end=math.ceil(width[1]),\n                y_end=math.ceil(height[1]),\n                # XXX: indexes start at 1\n                width_index=width_i + 1,\n                height_index=height_i + 1,\n            )\n            crops.append(crop)\n\n    # a 2x2 image is indexed like\n    # [1 3]\n    # [2 4]\n\n    return crops\n\n\ndef register_in_clipboard(data):\n    \"\"\"\n    Args:\n        data(str):\n    \"\"\"\n\n    # Check which operating system is running to get the correct copying keyword.\n    if platform.system() == \"Darwin\":\n        copy_keyword = \"pbcopy\"\n    elif platform.system() == \"Windows\":\n        copy_keyword = \"clip\"\n    else:\n        raise OSError(\"Current os not supported. Only [Darwin, Windows]\")\n\n    subprocess.run(copy_keyword, universal_newlines=True, input=data)\n    return\n\n\ndef generate_nk(\n    width_max,\n    height_max,\n    width_source,\n    height_source,\n    node_name,\n):\n    \"\"\"\n\n    Args:\n        width_max(int):\n        height_max(int):\n        width_source(int):\n        height_source(int):\n        node_name(str):\n\n    Returns:\n        str: .nk formatted string representing the nodegraph\n    \"\"\"\n\n    crop_coordinates = generate_crop_coordinates(\n        width_max,\n        height_max,\n        width_source,\n        height_source,\n    )\n\n    out = \"\"\n\n    master_write_id = \"C171d00\"\n    pass_metadata_key = \"__crop/pass_id\"\n\n    master_write = WRITE_MASTER_NUKE_TEMPLATE.replace(\n        \"%METADATA_KEY%\", pass_metadata_key\n    )\n    master_write = master_write.replace(\"%ICD_NODE%\", node_name)\n    out += \"clone node7f6100171d00|Write|21972 \{\}\\n\".format(master_write)\n    out += \"set \{\} [stack 0]\\n\".format(master_write_id)\n\n    for index, crop_coordinate in enumerate(\n        crop_coordinates\n    ):  # type: int, CropCoordinate\n        pass_nk = PASS_NUKE_TEMPLATE\n        pass_id = \"\{\}x\{\}\".format(\n            crop_coordinate.width_index, crop_coordinate.height_index\n        )\n        pos_x = 125 * index\n\n        pass_nk = pass_nk.replace(\"%PASS_ID%\", str(pass_id))\n        pass_nk = pass_nk.replace(\"%PASS_XPOS%\", str(pos_x))\n        pass_nk = pass_nk.replace(\"%WRITE_CLONE_ID%\", str(master_write_id))\n        pass_nk = pass_nk.replace(\"%METADATA_KEY%\", str(pass_metadata_key))\n        pass_nk = pass_nk.replace(\"%BOX_X%\", str(crop_coordinate.x_end))\n        pass_nk = pass_nk.replace(\"%BOX_Y%\", str(crop_coordinate.y_end))\n        pass_nk = pass_nk.replace(\"%BOX_R%\", str(crop_coordinate.x_start))\n        pass_nk = pass_nk.replace(\"%BOX_T%\", str(crop_coordinate.y_start))\n\n        out += \"\{\}push $\{\}\\n\".format(pass_nk, master_write_id)\n        continue\n\n    LOGGER.info(\"[generate_nk] Finished.\")\n    return out\n\n\ndef run():\n    def _check(variable, name):\n        if not variable:\n            raise ValueError(\"\{\} can't be False/None/0\".format(name))\n\n    LOGGER.info(\"[run] Started.\")\n\n    width_max = nuke.thisNode()[\"width_max\"].getValue()\n    height_max = nuke.thisNode()[\"height_max\"].getValue()\n    width_source = nuke.thisNode()[\"width_source\"].getValue()\n    height_source = nuke.thisNode()[\"height_source\"].getValue()\n    node_name = nuke.thisNode().name()\n\n    _check(width_max, \"width_max\")\n    _check(height_max, \"height_max\")\n    _check(width_source, \"width_source\")\n    _check(height_source, \"height_source\")\n\n    nk_str = generate_nk(\n        width_max=width_max,\n        height_max=height_max,\n        width_source=width_source,\n        height_source=height_source,\n        node_name=node_name,\n    )\n    register_in_clipboard(nk_str)\n\n    LOGGER.info(\"[run] Finished. Nodegraph copied to clipboard.\")\n    return\n\n\n# remember: this modifies the root LOGGER only if it never has been before\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(levelname)-7s | %(asctime)s [%(name)s] %(message)s\",\n    stream=sys.stdout,\n)\nrun()\n" +STARTLINE}
 addUserKnob {26 info l " " T "press ctrl+v in the nodegraph after clicking the above button\nyou can then edit the top-most write node and\nunclone all the other write node once done."}
 addUserKnob {26 "" +STARTLINE}
 addUserKnob {26 header_step3 l " " T "<h2>Step3</h2>"}
 addUserKnob {26 desc_step3 l " " T "- render all write node to disk\n- then click the under:"}
 addUserKnob {22 combine_script l "Combine From Export Directory" T "import abc\nimport logging\nimport os\nimport subprocess\nimport sys\n\nimport nuke\n\nLOGGER = logging.getLogger(__name__)\n\n\nclass BaseCombineMethod:\n    name = \"\"\n\n    def __init__(self, *args, **kwargs):\n        if not self.name:\n            raise NotImplementedError(\"name attribute must be implemented\")\n\n    @abc.abstractmethod\n    def run(self, directory, combined_filename, delete_crops):\n        \"\"\"\n\n        Args:\n            directory(str): filesystem path to an existing directory with file inside\n            combined_filename(str): valid filesystem file name without extension\n            delete_crops(bool): True to delete crops once combined\n\n        Returns:\n            str: filesystem path to the combined file created\n        \"\"\"\n        pass\n\n\nclass OiiotoolCombineMethod(BaseCombineMethod):\n    name = \"oiiotool executable\"\n\n    def __init__(self, oiiotool_path=None, *args, **kwargs):\n        super(OiiotoolCombineMethod, self).__init__()\n        if oiiotool_path:\n            self._oiiotool_path = oiiotool_path\n        else:\n            self._oiiotool_path = os.getenv(\"OIIOTOOL\")\n\n        if not self._oiiotool_path:\n            raise ValueError(\"No oiiotool path found.\")\n        if not os.path.exists(self._oiiotool_path):\n            raise ValueError(\n                \"Oiiotool path provide doesn't exist: \{\}\".format(oiiotool_path)\n            )\n\n    def run(self, directory, combined_filename, delete_crops):\n        # XXX: we assume directory only contains the images we want to combine but\n        #   we still perform some sanity checks just in case\n        src_files = [\n            os.path.join(directory, filename) for filename in os.listdir(directory)\n        ]\n        src_ext = os.path.splitext(src_files[0])[1]\n        src_files = [\n            filepath\n            for filepath in src_files\n            if os.path.isfile(filepath) and filepath.endswith(src_ext)\n        ]\n        if not src_files:\n            raise ValueError(\n                \"Cannot find crops files to combine in \{\}\".format(directory)\n            )\n\n        dst_file = os.path.join(directory, \"\{\}\{\}\".format(combined_filename, src_ext))\n\n        src_files.sort()\n        # name of a file is like \"0x2.jpg\"\n        mosaic_max = os.path.splitext(os.path.basename(src_files[-1]))[0]\n        mosaic_max_height = int(mosaic_max.split(\"x\")[1])\n\n        # order of source files matter, for a 2x3 image we need to convert like :\n        # [1 4] > [1 2]\n        # [2 5] > [3 4]\n        # [3 6] > [5 6]\n        print([os.path.basename(p) for p in src_files])\n        buffer = []\n        for row_index in range(mosaic_max_height):\n            buffer += src_files[row_index::mosaic_max_height]\n        src_files = buffer\n        print([os.path.basename(p) for p in src_files])\n\n        command = [self._oiiotool_path]\n        command += src_files\n        # https://openimageio.readthedocs.io/en/latest/oiiotool.html#cmdoption-mosaic\n        command += [\"--mosaic\", mosaic_max]\n        command += [\"-o\", dst_file]\n\n        LOGGER.info(\"about to call oiiotool with \{\}\".format(command))\n        subprocess.check_call(command)\n\n        if not os.path.exists(dst_file):\n            raise RuntimeError(\n                \"Unexpected issue: combined file doesn't exist on disk at <\{\}>\"\n                \"\".format(dst_file)\n            )\n\n        if delete_crops:\n            for src_file in src_files:\n                os.unlink(src_file)\n\n        return dst_file\n\n\nclass PillowCombineMethod(BaseCombineMethod):\n    name = \"python Pillow library\"\n\n    def __init__(self, *args, **kwargs):\n        super(PillowCombineMethod, self).__init__()\n        import Pillow\n\n    def run(self, directory, combined_filename, delete_crops):\n        # TODO\n        raise NotImplementedError()\n\n\nCOMBINE_METHODS = [\n    OiiotoolCombineMethod,\n    PillowCombineMethod,\n]\n\n\ndef run():\n    LOGGER.info(\"[run] Started.\")\n\n    export_dir = nuke.thisNode()[\"export_directory\"].getValue()  # type: str\n    combined_filename = nuke.thisNode()[\"combined_filename\"].getValue()  # type: str\n    delete_crops = nuke.thisNode()[\"delete_crops\"].getValue()  # type: bool\n    oiiotool_path = nuke.thisNode()[\"oiiotool_path\"].getValue()  # type: str\n\n    if not export_dir or not os.path.isdir(export_dir):\n        raise ValueError(\n            \"Invalid export directory <\{\}>: not found on disk.\".format(export_dir)\n        )\n\n    combine_instance = None\n\n    for combine_method_class in COMBINE_METHODS:\n        try:\n            combine_instance = combine_method_class(oiiotool_path=oiiotool_path)\n        except Exception as error:\n            LOGGER.debug(\"skipping class \{\}: \{\}\".format(combine_method_class, error))\n\n    if not combine_instance:\n        raise RuntimeError(\n            \"No available method to combine the renders found. Available methods are:\\n\{\}\"\n            \"\\nSee documentation for details.\"\n            \"\".format([method.name for method in COMBINE_METHODS])\n        )\n\n    LOGGER.info(\"[run] about to combine directory \{\} ...\".format(export_dir))\n    combined_filepath = combine_instance.run(\n        directory=export_dir,\n        delete_crops=delete_crops,\n        combined_filename=combined_filename,\n    )\n    nuke.message(\"Successfully created combine file: \{\}\".format(combined_filepath))\n    LOGGER.info(\"[run] Finished.\")\n\n\n# remember: this modifies the root LOGGER only if it never has been before\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(levelname)-7s | %(asctime)s [%(name)s] %(message)s\",\n    stream=sys.stdout,\n)\nrun()\n" +STARTLINE}
 addUserKnob {6 delete_crops l "Delete Crops" t "Delete crops files created once the combined image is finished." +STARTLINE}
 addUserKnob {26 "" +STARTLINE}
 addUserKnob {26 header_combine l " " T "<h2>Combine Settings</h2>"}
 addUserKnob {2 oiiotool_path l "oiiotool path" +STARTLINE}
 addUserKnob {20 About}
 addUserKnob {26 toolName l name T ImageCropDivide}
 addUserKnob {26 toolVersion l version T 0.8.0}
 addUserKnob {26 toolAuthor l author T "<a style=\"color: rgb(200,200,200);\" href=\"https://mrlixm.github.io/\">Liam Collod</a>"}
 addUserKnob {26 toolDescription l description T "Reshape a colorspace gamut and plot it on the CIE xy space."}
 addUserKnob {26 toolUrl l url T "<a style=\"color: rgb(200,200,200);\" href=\"https://github.com/MrLixm/Foundry_Nuke\">https://github.com/MrLixm/Foundry_Nuke</a>"}
}
 Input {
  inputs 0
  name Input1
  xpos 0
 }
 Output {
  name Output1
  xpos 0
  ypos 300
 }
end_group
